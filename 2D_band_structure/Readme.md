

## Relaxation

need POSCAR, POTCAR, INCAR (KPOINTS DOESNT INFLUENCE RELAXATION??):

```
                                   File: POSCAR                                                                                     
Graphite Lattice
1.0
 2.4410462393  0.0000000000  0.0000000000 
-1.2205231197  2.1140080551  0.0000000000 
 0.0000000000  0.0000000000 10.0000000000 
C
2
Cartesian
 0.0000000000  0.0000000000  0.0000000000 
 0.0000000000  1.4093387034  0.0000000000 
```

I. Standardize POSCAR, ensuring that the z-coordinate center of the material aligns with |c|/2.
Since the K-path generated by VASPKIT relies on a standardized primitive cell, it's essential to correctly standardize the crystal cell for 2D materials using VASPKIT. Here's a series of steps to ensure this standardization process:

   1. Use VASPKIT version `921` or `923`.
   2. Apply standardization specifically for 2D materials.
   3. Ensure that the z-coordinate center of the 2D material is at |c|/2 (i.e., fractional coordinate z = 0.5).
   4. Utilize VASPKIT 923 for the standardization process, which involves:
      - Placing a vacuum layer in the z-direction.
      - Centering the 2D material along the z-coordinate.

```
                                   File: POSCAR_REV                                                                                      
Graphite Lattice
   1.000
    2.4410462392999999    0.0000000000000000    0.0000000000000000
   -1.2205231196999993    2.1140080551000002    0.0000000000000000
    0.0000000000000006    0.0000000000000011   10.0000000000000000
C
2
Cartesian
    0.0000000000000000    0.0000000000000001    5.0000000000000000     C1
    0.0000000000000005    1.4093387034000002    5.0000000000000000     C2

```
   5. rename by using : `cp POSCAR_REV POSCAR'

II. Create INCAR file to perform Standard Relaxation (geometry optimization) using vaspkit `101` and `SR`, the default is : 
```                                                                             

                                      File: INCAR                                                                                      

Global Parameters
ISTART =  1            (Read existing wavefunction, if there)
ISPIN  =  1            (Non-Spin polarised DFT)
# ICHARG =  11         (Non-self-consistent: GGA/LDA band structures)
LREAL  = .FALSE.       (Projection operators: automatic)
# ENCUT  =  400        (Cut-off energy for plane wave basis set, in eV)
# PREC   =  Accurate   (Precision level: Normal or Accurate, set Accurate when perform structure lattice relaxation calculation)
LWAVE  = .TRUE.        (Write WAVECAR or not)
LCHARG = .TRUE.        (Write CHGCAR or not)
ADDGRID= .TRUE.        (Increase grid, helps GGA convergence)
# LVTOT  = .TRUE.      (Write total electrostatic potential into LOCPOT or not)
# LVHAR  = .TRUE.      (Write ionic + Hartree electrostatic potential into LOCPOT or not)
# NELECT =             (No. of electrons: charged cells, be careful)
# LPLANE = .TRUE.      (Real space distribution, supercells)
# NWRITE = 2           (Medium-level output)
# KPAR   = 2           (Divides k-grid into separate groups)
# NGXF    = 300        (FFT grid mesh density for nice charge/potential plots)
# NGYF    = 300        (FFT grid mesh density for nice charge/potential plots)
# NGZF    = 300        (FFT grid mesh density for nice charge/potential plots)

Electronic Relaxation
ISMEAR =  0            (Gaussian smearing, metals:1)
SIGMA  =  0.05         (Smearing value in eV, metals:0.2)
NELM   =  90           (Max electronic SCF steps)
NELMIN =  6            (Min electronic SCF steps)
EDIFF  =  1E-08        (SCF energy convergence, in eV)
# GGA  =  PS           (PBEsol exchange-correlation)

Ionic Relaxation
NSW    =  100          (Max ionic steps)
IBRION =  2            (Algorithm: 0-MD, 1-Quasi-New, 2-CG)
ISIF   =  2            (Stress/relaxation: 2-Ions, 3-Shape/Ions/V, 4-Shape/Ions)
EDIFFG = -2E-02        (Ionic convergence, eV/AA)
# ISYM =  2            (Symmetry: 0=none, 2=GGA, 3=hybrids)
```

III. Generate POTCAR using vaspkit `103`

IV. Run calculation

## SCF

I. After the SR calculation is complete, make a new directory called scf using 'mkdir scf' and then change your active directory to that folder 'cd scf' and then copy in the CONTCAR as POSCAR 'cp ../CONTCAR POSCAR' and the POTCAR 'cp ../POTCAR .'

II. Create INCAR file to perform Static-Calculations (SCF) using vaspkit `101` and `ST`, the default is : 

```
                                    File: INCAR    
Global Parameters
ISTART =  1            (Read existing wavefunction, if there)
ISPIN  =  1            (Non-Spin polarised DFT)
# ICHARG =  11         (Non-self-consistent: GGA/LDA band structures)
LREAL  = .FALSE.       (Projection operators: automatic)
# ENCUT  =  400        (Cut-off energy for plane wave basis set, in eV)
# PREC   =  Accurate   (Precision level: Normal or Accurate, set Accurate when perform structure lattice relaxation calculation)
LWAVE  = .TRUE.        (Write WAVECAR or not)
LCHARG = .TRUE.        (Write CHGCAR or not)
ADDGRID= .TRUE.        (Increase grid, helps GGA convergence)
# LVTOT  = .TRUE.      (Write total electrostatic potential into LOCPOT or not)
# LVHAR  = .TRUE.      (Write ionic + Hartree electrostatic potential into LOCPOT or not)
# NELECT =             (No. of electrons: charged cells, be careful)
# LPLANE = .TRUE.      (Real space distribution, supercells)
# NWRITE = 2           (Medium-level output)
# KPAR   = 2           (Divides k-grid into separate groups)
# NGXF    = 300        (FFT grid mesh density for nice charge/potential plots)
# NGYF    = 300        (FFT grid mesh density for nice charge/potential plots)
# NGZF    = 300        (FFT grid mesh density for nice charge/potential plots)

Static Calculation
ISMEAR =  0            (gaussian smearing method)
SIGMA  =  0.05         (please check the width of the smearing)
LORBIT =  11           (PAW radii for projected DOS)
NEDOS  =  2001         (DOSCAR points)
NELM   =  60           (Max electronic SCF steps)
EDIFF  =  1E-08        (SCF energy convergence, in eV)
```
III. Run calculation

### Bands, NSCF

I. After the SCF calculation is completed, make a directory called dos using 'mkdir dos' and then change your active directory to that folder 'cd dos' and then copy in the CONTCAR as POSCAR 'cp ../CONTCAR POSCAR' and the POTCAR 'cp ../POTCAR .'

II. Copy in the 'CHGCAR' from the SCF folder 'cp ../CHGCAR .'

III. Create K-Path for 2D Structure using vaspkit '302'. This creates several files, but we want 'KPATH.in' and copy it to 'KPOINT' using 'cp KPATH.in KPOINT'

IV. Delete the INCAR created from the previous step using 'rm INCAR' and then create a new INCAR file to perform DOS calculations using 'nano INCAR' :

```
                                    File: INCAR                                                                                      
##### initial I/O #####
SYSTEM = MoS2
ICHARG = 11
LWAVE = .TRUE.
LCHARG = .TRUE.
LVTOT = .FALSE.
LVHAR = .FALSE.
LELF = .FALSE.
LORBIT = 11
NEDOS = 1000

##### SCF #####
#ENCUT = 500
ISMEAR = 0
SIGMA = 0.05
EDIFF = 1E-6
NELMIN = 5
NELM = 300
GGA = PE
LREAL = .FALSE.
#PREC = Accurate
```
V. Run calculation


### Plotting Band Structure 

```
import numpy as np
import matplotlib.pyplot as plt
import os
from scipy.ndimage import gaussian_filter1d


# Read data from the file
def read_pdos(file_path):
    data = np.loadtxt(file_path, skiprows=1)  # Assuming the first row contains strings

    # Extract labels from the comment line
    with open(file_path, 'r') as file:
        comment_line = file.readline().strip()

    # Remove leading '#' and split the line into labels
    labels = comment_line[1:].split()[1:]

    # Extract data columns
    energy_values = data[:, 0]  # First column as x-axis values
    pdos_values = data[:, 1:]  # Data excluding the first column

    return energy_values, pdos_values, labels


def read_doscar(file_path):
    total_dos=[]
    with open(file_path, 'r') as file:
        # Skip the first four header lines
        for _ in range(5):
            next(file)
        
        # Read the 5th line to get the desired value
        fifth_line = next(file).split()
        E_fermi_value = float(fifth_line[3])  # Extracting the fourth item
        NEDOS_value = float(fifth_line[2])  # Extracting the 3rd item
        # Initialize lists for energy values and total DOS
        energy_values = []
        total_dos = []

                
        # Initialize line counter
        line_count = 0

        # Read total DOS data from the remaining lines
        for line in file:
            # Increment line counter
            line_count += 1

            # Check if line count exceeds NEDOS_value
            if line_count > NEDOS_value:
                break

            data = line.split()
            # Ensure the line has enough elements to avoid index errors
            if len(data) >= 2:
                energy_values.append(float(data[0]))
                total_dos.append(float(data[1]))
                


    # Convert lists to numpy arrays for further processing
    energy_values_np = np.array(energy_values)
    total_dos_np = np.array(total_dos)

    energy_values_np -= E_fermi_value

    return energy_values_np, total_dos_np


# Function to smooth data using Gaussian filter
def smooth_data(data, sigma=2):
    return gaussian_filter1d(data, sigma)

doscar_path_M = '/nas/longleaf/home/............/scf/dos/DOSCAR'
energy_values_M, total_dos_M = read_doscar(doscar_path_M)


#pdos_path_GD = '/nas/longleaf/home/jarkeith/dissertation/........./D_PDOS.dat'
#energy_values_GDA_pdos, total_pdos_GDA, labels = read_pdos(pdos_path_GDA)
i=9



sigma = 0  # Adjust the sigma value as needed

# Smooth total DOS data using Gaussian filter
if sigma !=0:
    total_dos_M = smooth_data(total_dos_M, sigma)
    
# Plot the data
plt.figure(figsize=(12, 10))

plt.plot(energy_values_M, total_dos_M, label='M DOS', color='blue')

plt.axhline(0, color='black', linestyle='--', linewidth=0.8)  # Horizontal line at y=0
plt.xlabel('Energy (eV)')
plt.ylabel('Density of States')
if sigma !=0:
    plt.title(f'Density of States (DOS), Gaussian Smoothing - Sigma = {sigma}')
else: 
    plt.title(f'Density of States (DOS)')
plt.xlim(-5, 5)
#plt.ylim(0, 1)
plt.legend()
plt.grid(True)
#plt.scatter([-1.35], [14], marker='o', color='red', s=200, label='Point of Interest')
#plt.scatter([3.98], [4], marker='*', color='red', s=200, label='Point of Interest')
#plt.scatter([.7], [18], marker='*', color='green', s=200, label='Point of Interest')
#plt.scatter([-.8], [18], marker='o', color='green', s=100, label='Point of Interest')

plt.show()
```

### Ploting DOS

I. Run vaspkit `211` to create files and set Fermi Energy to zero eV in all the files (EXCEPT FOR DOSCAR!)

```
import matplotlib.pyplot as plt

path_M = '/nas/longleaf/home/........../scf/dos/'


# Read data from the file
file_path = str(path_M)+'BAND.dat'
data = {'bands': []}
num_bands = 0  # Initialize num_bands to 0

with open(file_path, 'r') as file:
    current_band = None
    for line in file:
        if line.startswith('# NBANDS:'):
            num_bands = int(line.split()[2])
        elif line.startswith('# Band-Index'):
            current_band = {'k_path': [], 'energy_levels': []}
            data['bands'].append(current_band)
        elif line.startswith('#') or not line.strip():
            continue
        else:
            values = line.split()
            if len(values) >= 2:
                k_path, energy_level = map(float, values[:2])
                current_band['k_path'].append(k_path)
                current_band['energy_levels'].append(energy_level)

                
selected_data = {'bands': []}

# Iterate over each band's data
for band_data in data['bands']:
    # Check if any energy level falls within the specified range
    energy_levels = [energy_level for energy_level in band_data['energy_levels'] if -15 <= energy_level <= 6]
    
    # If at least one energy level falls within the range, add the band to selected_data
    if energy_levels:
        selected_band = {'k_path': band_data['k_path'], 'energy_levels': energy_levels}
        selected_data['bands'].append(selected_band)                

# Plotting
for band_index, band_data in enumerate(data['bands']):
    label = f'Band {band_index + 1}'
    plt.plot(band_data['k_path'], band_data['energy_levels'], color='blue', label=label)

plt.xlabel('K-Path (1/A)')
plt.ylabel('Energy-Level (eV)')
#plt.legend()
plt.title('Band Structure')
plt.ylim(-15, 10)
plt.show()

import matplotlib.pyplot as plt

# Plotting
for band_index, band_data in enumerate(selected_data['bands']):
    # Check if the lengths of 'k_path' and 'energy_levels' are equal
    if len(band_data['k_path']) != len(band_data['energy_levels']):
        print(f"Skipping band {band_index + 1} due to mismatched array lengths.")
        continue
    
    label = f'Band {band_index + 1}'
    plt.plot(band_data['k_path'], band_data['energy_levels'], color='blue', label=label)

plt.xlabel('K-Path (1/A)')
plt.ylabel('Energy-Level (eV)')
plt.title('Band Structure')
plt.ylim(-15, 10)
plt.show()

```
